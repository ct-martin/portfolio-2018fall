webpackJsonp([25],{"/9BO":function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var s=n("P2dm"),a=n("VU/8")(null,s.a,!1,null,null,null);a.options.__file="pages/projects/battleship/stateless-states.vue",t.default=a.exports},P2dm:function(e,t,n){"use strict";var s=function(){var e=this.$createElement;this._self._c;return this._m(0)};s._withStripped=!0;var a={render:s,staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",[n("h2",{staticClass:"title"},[e._v("Pains of Stateless State Management")]),n("p",[e._v("\n      As it would turn out, synchronizing states is really hard.\n    ")]),n("p",[e._v("\n      The tech used for this app is fairly common.\n      The client is rendered using p5.js, the server uses Node.js, Redis stores states, & data is passed between the two using websockets via socket.io\n    ")]),n("p",[e._v("\n      The biggest difficulty is that there are multiple devices per player and multiple players connected at the same time.\n      I have to make sure that all necessary data is synchronized efficiently, but I also need a single source of truth to fall back on.\n      I ended up accomplishing this by using an MVC-like approach where the server tells the client the basic data it needs to render, and the client relies on the server to validate actions taken by the player.\n      Since there are multiple connections for a given user and a single connection doesn’t automatically know the other connections, I have to rely on Redis to store the other connection IDs to tell them information.\n      Additionally, I’ve had connections drop randomly and it’s necessary to not lose the game’s state because of that.\n    ")]),n("p",[e._v("\n      Redis is also an important part because it helps a lot in development testing (I can restart the client or server after fixing a logic bug and keep going without re-doing the entire game from scratch).\n      Aside from testing though, I’ve had more than a few times when the Node server or dual-touchscreen laptop has crashed, which is automatically accounted for the same way.\n      Redis also allows horizontal scaling in the future.\n      Due to the simplicity to implement and the near-complete reliance on Redis to control state, scaling in theory already works, but I haven’t tested it yet.\n    ")]),n("p",[e._v("\n      The only variables that get stored on the server are the socket ID and the session ID (assigned via Express cookies, synchronized with Redis as well).\n      This is because it’s done as part of the handshake and I otherwise have no way to identify the individual connection as well as the user as a set of multiple connection.\n      This data is safe to store in a local variable in the connection event handler because it doesn’t affect the gameplay since it doesn’t contain any of the information about the game state itself, just who the connection is.\n      In order to maintain this single source of truth, the game event logic has needed to be stateless.\n      This makes it a ton easier to synchronize state, but makes individual events more complex to code.\n      It’s honestly more of a mindset thing rather than a coding thing since a variable is being updated somewhere, but having to think in database queries (with callbacks) rather than OOP-like variable changing for everything is more complex to me since I’m less familiar with it.\n    ")]),n("p",[e._v("\n      Another caveat that comes with Redis as the source of truth though is that I have to query every time I want a variable because it’s not stored in the server’s memory.\n      This essentially doubles the effort it takes to do simple operations since I can’t reference an object like you normally would in OOP. Instead of:\n    ")]),n("pre",[e._v("socket.on('ingame', cb2 => {\n  if (gamesBySession.exists(sessionid)) {\n    const gameId = gamesBySession[sessionid];\n    console.log(`'${sessionid}' has rejoined game '${gameId}'`);\n    return cb2(gameId);\n  }\n  return cb2(-1);\n}));\n")]),n("p",[e._v("\n      I have to do:\n    ")]),n("pre",[e._v("socket.on('ingame', cb2 =>\n redisClient.exists(`gameOf.${sessionid}`, (err, inGame) => {\n  if (inGame === 1) {\n    return redisClient.get(`gameOf.${sessionid}`, (err2, gameId) => {\n      console.log(`'${data.session}' has rejoined game '${gameId}'`);\n      return cb2(gameId);\n    });\n  }\n  return cb2(-1);\n}));\n")]),n("p",[e._v("\n      As you can see, the calculation & event logic is about the same, but referencing variables is significantly more complex.\n      Additionally, since I need an error variable for each query, I’ve ended up appending the level of nesting to the end of it, which is bad practice and then I end up with "),n("code",[e._v("err9")]),e._v(" and such for variable names.\n    ")]),n("p",[e._v("\n      However, Redis makes this a lot more complicated because node_redis uses callbacks or Promises to get data from it.\n      When you’re querying a lot of variables, you very quickly get into callback hell, regardless of which you use.\n      Using Multi-exec or "),n("code",[e._v("Promise.all()")]),e._v(" also don’t work since I need to get the values of all the queried keys.\n      Finally, there are some differences between node_redis and the Redis spec for how some commands are handled, and these are not documented.\n      For example, the "),n("a",{attrs:{href:"https://redis.io/commands/lindex",target:"_blank"}},[e._v("Redis docs say for LINDEX")]),e._v(", “When the value at key is not a list, an error is returned.”\n      However, node_redis returns no error, but rather NULL for the return value.\n      It something that a debug log can tell you, but these undocumented differences makes debugging a lot longer and are an unneeded hassle.\n    ")]),n("p",[e._v("\n      Finally, I haven’t finished debugging why yet, but I’ve found that non-"),n("code",[e._v("HttpOnly")]),e._v(" cookies seem to not get passed to the client when behind Cloudflare’s proxy.\n      I know this isn’t a proper way to identify users, but it works for the purposes of what I’m trying to accomplish and I need the "),n("code",[e._v("sessionid")]),e._v(" accessible to the JavaScript to identify the client to the server.\n      JSON Web Tokens would be a good replacement for the current scheme, but that’s more work for another time.\n    ")]),n("p",[e._v("\n      For future work on this I’m considering an OOP-style referencing scheme using method chaining even though individual variables wouldn’t work because of the stateless factor.\n      For example, the OOP "),n("code",[e._v("this.game.me.ships")]),e._v(" ("),n("code",[e._v("this.game.player(this).ships")]),e._v(" if static) would be "),n("code",[e._v("game(sessionid).me().ships()")]),e._v(".\n      While this isn’t “proper” OOP per say, it works, and I had some bad luck when I tried using ES6 class or Node’s "),n("code",[e._v("module.exports")]),e._v(" to do OOP methods before.\n      It also won’t be fun to implement due to everything being methods and the nesting on the variable side will probably be as bad as it is now, but it will make the game logic much cleaner to decouple the server & Redis communication from the game logic itself.\n    ")]),n("p",[e._v("\n      All in all, the result works, but wow, it was a pain at times.\n      What I had expected to be a sort of relaxing project to make a fun experience ended up being a learning experience in networking & state management I didn’t really expect.\n      It lacks some polish, particularly in the visuals, but as a proof of concept it did quite well.\n    ")])])}]};t.a=a}});